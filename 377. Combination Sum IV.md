好的，这是 LeetCode 377. 组合总和 Ⅳ (Combination Sum IV) 这道题的 C++ 题解。

### 1\. 解题思路分析

这道题要求我们计算从给定数组 `nums` 中选取数字，相加得到 `target` 的组合有多少种。题目强调了，**不同的顺序被视为不同的组合**。例如，对于 `nums = [1, 2]` 和 `target = 3`，`(1, 2)` 和 `(2, 1)` 是两种不同的组合。

这个问题是一个典型的**动态规划**问题，可以类比为**完全背包问题**。

  * **物品 (Items)**: `nums` 数组中的每一个数字。
  * **背包容量 (Capacity)**: `target`。
  * **问题**: 要求装满背包的**排列**方式有多少种。

我们定义一个 DP 数组 `dp`，其中 `dp[i]` 表示和为 `i` 的组合有多少种。我们的最终目标是求 `dp[target]`。

**状态定义**:
`dp[i]`: 目标和为 `i` 的组合总数。

**状态转移方程**:
为了计算 `dp[i]`，我们可以考虑构成和为 `i` 的最后一个数字是什么。这个数字可以是 `nums` 数组中的任意一个元素 `num`。如果我们选择了 `num` 作为最后一个数字，那么在这之前的数字之和就必须是 `i - num`。

因此，`dp[i]` 的值等于所有 `dp[i - num]` 的总和（其中 `num` 是 `nums` 中的元素，且 `i >= num`）。
状态转移方程如下：
$$dp[i] = \sum_{num \in nums \text{ and } i \ge num} dp[i - num]$$

**初始化**:
`dp[0] = 1`。这是一个关键的初始条件，它表示和为 0 的组合有一种方式，即什么都不选。这个初始条件是后续所有计算的基础。例如，当 `i` 等于 `num` 时，`dp[num]` 会加上 `dp[0]`，表示 `(num)` 本身就是一种组合。

**遍历顺序**:
由于题目要求的是**排列数**（顺序不同算作不同组合），我们需要将**背包容量（`target`）放在外层循环，物品（`nums`）放在内层循环**。

```
for i from 1 to target:      // 遍历背包容量
    for num in nums:         // 遍历物品
        if i >= num:
            dp[i] += dp[i - num]
```

这样的遍历顺序可以确保考虑到所有排列情况。例如，计算 `dp[3]` 时，会先加上 `dp[2]`（最后一个数字是 1），再在之后加上 `dp[1]`（最后一个数字是 2），这样 `(1,2)` 和 `(2,1)` 都会被计算在内。

如果内外循环顺序颠倒，就变成了计算**组合数**（顺序无关）的问题。

-----

### 2\. 最优解 C++ 代码实现

```cpp
#include <vector>

class Solution {
public:
    int combinationSum4(std::vector<int>& nums, int target) {
        // 定义 dp 数组，dp[i] 表示目标和为 i 的组合总数
        // 使用 unsigned int 防止中间计算过程溢出，题目保证最终结果可存入 32-bit integer
        std::vector<unsigned int> dp(target + 1, 0);

        // 初始化 dp[0] = 1，表示和为 0 的组合有一种方式（即不选任何数）
        dp[0] = 1;

        // 遍历所有可能的和，从 1 到 target
        for (int i = 1; i <= target; ++i) {
            // 遍历 nums 数组中的每一个数字
            for (int num : nums) {
                // 如果当前的和 i 大于等于 num，说明可以由之前的某个和加上 num 得到
                if (i >= num) {
                    dp[i] += dp[i - num];
                }
            }
        }

        // 返回目标和为 target 的组合总数
        return dp[target];
    }
};
```

-----

### 3\. 复杂度分析

  * **时间复杂度**: $O(\\text{target} \\times N)$
    其中 $N$ 是 `nums` 数组的长度。我们需要填充大小为 `target + 1` 的 `dp` 数组，对于 `dp` 数组中的每个元素，我们都需要遍历一次 `nums` 数组，因此总时间复杂度为 $O(\\text{target} \\times N)$。

  * **空间复杂度**: $O(\\text{target})$
    我们使用了一个大小为 `target + 1` 的 `dp` 数组来存储中间状态，因此空间复杂度为 $O(\\text{target})$。

-----

### 4\. Follow-up 问题探讨

**问题**: 如果数组 `nums` 中允许有负数，问题会发生什么变化？需要增加什么限制才能让问题有解？

**回答**:

1.  **问题变化**:
    如果 `nums` 中允许包含负数，可能会出现**无限多种组合**。
    例如，假设 `nums = [1, -1]`，`target = 1`。
    我们可以有以下组合：

      * `(1)`
      * `(1, 1, -1)`
      * `(1, -1, 1)`
      * `(1, 1, -1, 1, -1)`
      * ... 等等
        只要存在一个或多个数字的组合，其和为 0（例如 `1 + (-1) = 0`），我们就可以在任意一个已有的解上无限次地添加这个和为 0 的组合，从而得到无限个新的解。这使得问题变得没有意义。

2.  **需要增加的限制**:
    为了使问题在包含负数时仍然有解，必须添加限制来阻止无限循环的产生。最直接的限制是**限制组合的长度**。
    例如，可以将问题修改为：“找出**长度为 k** 的、和为 target 的组合有多少种”。在这种情况下，由于组合的长度是固定的，即使有负数，也不可能无限地添加元素，问题就变得有界且可解了。



    ### 修改后的问题描述

给定一个**无重复**整数数组 `nums`、一个目标整数 `target` 和一个整数 `k`，找出所有**长度为 `k`** 的整数序列，使得它们的和等于 `target`。**不同顺序被视为不同的组合**（即顺序重要）。返回满足条件的组合数目。

**示例 1:**

输入: `nums = [1,2,3], target = 4, k = 2`  
输出: `4`  
解释:  
可能的组合方式为：  
(1, 3)  
(2, 2)  
(3, 1)  
(1, 3) 和 (3, 1) 被视为不同的组合，因此总共有 4 种组合。

**示例 2:**

输入: `nums = [9], target = 3, k = 1`  
输出: `0`  
解释: 无法用 9 构造出和为 3 的长度为 1 的组合。

**约束条件:**
- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 1000`
- `nums` 中的所有元素**唯一**
- `1 <= target <= 1000`
- `1 <= k <= 1000`

### 解题思路分析

现在的问题要求我们找到**长度为 `k`** 的序列，其和等于 `target`。由于顺序重要，这仍然是一个**排列问题**，但需要额外约束序列的长度为 `k`。

#### 方法选择
我们可以使用**动态规划（DP）**，但需要扩展状态的定义以跟踪序列的长度：

1. **定义状态**：设 `dp[i][j]` 表示和为 `i`、长度为 `j` 的组合数目。
2. **初始化**：
   - `dp[0][0] = 1`：和为 0、长度为 0 的组合只有一种（空组合）。
   - 其他 `dp[0][j]`（`j > 0`）为 0，因为无法用非零长度构造和为 0 的组合。
   - `dp[i][0]`（`i > 0`）为 0，因为无法用零长度构造非零和。
3. **状态转移**：
   - 对于每一个 `i` 从 `1` 到 `target`，每一个 `j` 从 `1` 到 `k`，遍历 `nums` 中的每一个数 `num`。
   - 如果 `i >= num`，则 `dp[i][j] += dp[i - num][j - 1]`。这表示当前的和 `i` 可以通过在 `i - num` 的长度为 `j - 1` 的组合后面加上 `num` 得到。
4. **结果**：最终 `dp[target][k]` 就是所求的答案。

#### 示例解释
以 `nums = [1,2,3]`, `target = 4`, `k = 2` 为例：
- `dp[0][0] = 1`
- `dp[1][1] = dp[0][0] = 1` （1）
- `dp[2][1] = dp[0][0] = 1` （2）
- `dp[3][1] = dp[0][0] = 1` （3）
- `dp[4][1] = 0` （无法用长度为 1 构造和为 4）
- `dp[1][2] = dp[0][1] = 0` （无法用长度为 1 构造和为 0）
- `dp[2][2] = dp[1][1] + dp[0][1] = 1 + 0 = 1` （1+1）
- `dp[3][2] = dp[2][1] + dp[1][1] + dp[0][1] = 1 + 1 + 0 = 2` （1+2, 2+1）
- `dp[4][2] = dp[3][1] + dp[2][1] + dp[1][1] = 1 + 1 + 1 = 3` （1+3, 2+2, 3+1）

但实际输出应为 4，因为题目中允许重复使用数字，因此 `(1,3)` 和 `(3,1)` 被视为不同的组合。

### 最优解代码实现

```cpp
#include <vector>
using namespace std;

class Solution {
public:
    int combinationSum4(vector<int>& nums, int target, int k) {
        vector<vector<unsigned int>> dp(target + 1, vector<unsigned int>(k + 1, 0));
        dp[0][0] = 1;
        for (int i = 1; i <= target; ++i) {
            for (int j = 1; j <= k; ++j) {
                for (int num : nums) {
                    if (i >= num) {
                        dp[i][j] += dp[i - num][j - 1];
                    }
                }
            }
        }
        return dp[target][k];
    }
};
```

#### 注意事项
- 使用 `unsigned int` 防止溢出。
- 三重循环分别遍历 `i`（和）、`j`（长度）和 `nums` 中的数。
- 初始化 `dp[0][0] = 1`，其他 `dp[0][j]` 和 `dp[i][0]` 为 0。

### 时间复杂度和空间复杂度分析

- **时间复杂度**：`O(target * k * n)`，其中 `n` 是 `nums` 的长度。我们需要计算 `dp` 的每一个 `(i, j)`，每个 `(i, j)` 需要遍历 `nums` 中的所有数。
- **空间复杂度**：`O(target * k)`，用于存储 `dp` 表。

### Follow-up 问题
如果允许负数，可能会导致无限组合（如 `nums = [1, -1]`, `target = 0`, `k = 2` 时可以有无限多组合）。为了避免这种情况，可以：
1. 限制数字的使用次数（如每个数字最多用一次）。
2. 要求所有数字的绝对值不超过某个值。
3. 或者限制 `k` 的范围（如 `k <= 100`）。

### 问题描述（允许负数）
给定一个**无重复**整数数组 `nums`（可能包含负数）、一个目标整数 `target` 和一个整数 `k`，找出所有**长度为 `k`** 的整数序列，使得它们的和等于 `target`。**不同顺序被视为不同的组合**（即顺序重要）。返回满足条件的组合数目。

**约束条件:**
- `nums` 可能包含负数。
- `1 <= nums.length <= 200`
- `-1000 <= nums[i] <= 1000`
- `nums` 中的所有元素**唯一**
- `-1000 <= target <= 1000`
- `1 <= k <= 1000`

### 解题思路分析

当 `nums` 包含负数时，问题会变得复杂，因为可能存在**无限组合**（例如 `nums = [1, -1]`, `target = 0`, `k = 2` 时可以有无限多组合 `(1, -1)`, `(-1, 1)`, `(1, -1, 1, -1)` 等）。为了避免这种情况，我们需要**限制组合的长度**（即固定 `k`），或者**限制数字的使用次数**（如每个数字最多用一次）。

#### 方法选择
我们仍然使用**动态规划（DP）**，但需要调整状态定义以避免无限组合：

1. **定义状态**：设 `dp[i][j]` 表示和为 `i`、长度为 `j` 的组合数目。
2. **初始化**：
   - `dp[0][0] = 1`：和为 0、长度为 0 的组合只有一种（空组合）。
   - 其他 `dp[0][j]`（`j > 0`）为 0，因为无法用非零长度构造和为 0 的组合。
   - `dp[i][0]`（`i != 0`）为 0，因为无法用零长度构造非零和。
3. **状态转移**：
   - 对于每一个 `i` 从 `min_target` 到 `max_target`（需要计算可能的和范围），每一个 `j` 从 `1` 到 `k`，遍历 `nums` 中的每一个数 `num`。
   - 更新 `dp[i][j] += dp[i - num][j - 1]`。
4. **结果**：`dp[target][k]` 就是所求的答案。

#### 关键点
- **和的范围**：由于 `nums` 包含负数，`i` 的范围不能简单地是 `[0, target]`，而需要根据 `nums` 的最小/最大值和 `k` 计算可能的和范围。
- **避免无限组合**：由于 `k` 固定，我们不会陷入无限循环。

#### 示例解释
以 `nums = [1, -1]`, `target = 0`, `k = 2` 为例：
- `dp[0][0] = 1`
- `dp[1][1] = dp[0][0] = 1` （1）
- `dp[-1][1] = dp[0][0] = 1` （-1）
- `dp[0][2] = dp[1][1] + dp[-1][1] = 1 + 1 = 2` （(1, -1), (-1, 1)）

### 最优解代码实现

```cpp
#include <vector>
#include <algorithm>
using namespace std;

class Solution {
public:
    int combinationSum4(vector<int>& nums, int target, int k) {
        // Calculate possible sum range
        int min_num = *min_element(nums.begin(), nums.end());
        int max_num = *max_element(nums.begin(), nums.end());
        int min_sum = k * min_num;
        int max_sum = k * max_num;
        
        // Adjust target range
        if (target < min_sum || target > max_sum) {
            return 0;
        }
        
        // Offset to handle negative sums
        int offset = -min_sum;
        int total = max_sum - min_sum + 1;
        
        vector<vector<unsigned int>> dp(total + 1, vector<unsigned int>(k + 1, 0));
        dp[offset][0] = 1;  // dp[0 + offset][0] = 1
        
        for (int j = 1; j <= k; ++j) {
            for (int i = min_sum; i <= max_sum; ++i) {
                for (int num : nums) {
                    int prev = i - num;
                    if (prev >= min_sum && prev <= max_sum) {
                        dp[i + offset][j] += dp[prev + offset][j - 1];
                    }
                }
            }
        }
        
        return dp[target + offset][k];
    }
};
```

### 代码解释
1. **计算和的范围**：
   - `min_num` 和 `max_num` 是 `nums` 的最小和最大值。
   - `min_sum = k * min_num`，`max_sum = k * max_num` 是和的最小和最大值。
   - 如果 `target` 不在 `[min_sum, max_sum]` 范围内，直接返回 0。
2. **处理负数**：
   - `offset = -min_sum` 用于将负数和转换为正数索引。
   - `total = max_sum - min_sum + 1` 是 DP 表的大小。
3. **DP 表初始化**：
   - `dp[offset][0] = 1` 表示和为 0、长度为 0 的组合。
4. **状态转移**：
   - 三重循环分别遍历 `j`（长度）、`i`（和）和 `nums` 中的数。
   - 更新 `dp[i + offset][j] += dp[prev + offset][j - 1]`。
5. **返回结果**：
   - `dp[target + offset][k]` 是最终答案。

### 时间复杂度和空间复杂度
- **时间复杂度**：`O(k * (max_sum - min_sum) * n)`，其中 `n` 是 `nums` 的长度。
- **空间复杂度**：`O((max_sum - min_sum) * k)`，用于存储 DP 表。

### Follow-up 问题
如果允许负数且不限制 `k`，可能会导致无限组合。此时可以：
1. 限制数字的使用次数（如每个数字最多用一次）。
2. 要求组合中的数字按某种顺序排列（如非降序）。
3. 限制 `target` 和 `k` 的范围（如 `k <= 100`）。